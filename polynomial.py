polynomial - Jerod Junkinsimport mathimport collections.abcdef _trim(data):    if data:        last_index = -1        while abs(last_index) <= len(data) and data[last_index] == 0.0:            last_index -= 1                    if last_index == -1:            return tuple(data)        else:            return tuple(data[0:last_index+1])    else:        return tuple(data)def _pad(data1, data2):    m = max(len(data1), len(data2))    if len(data1) < m:        data1 = tuple(list(data1) + [0.0] * (m - len(data1)))    elif len(data2) < m:        data2 = tuple(list(data2) + [0.0] * (m - len(data2)))    return data1, data2# Replace the "pass" statements with an actual implementation of each# method/function so that the class behaves as expected. See the hw62main.py# file for examples of the output that each of the methods should produce.# I recommend building the class in steps:# first, get __init__, __repr__ and __str__ to work as expected.# After that, get degree, __pos__ and __neg__ to work as expected.# Then, try for __add__, __radd__, etc., testing as you go.class Polynomial:        # initialize a polynomial using data of one of the following forms:    # 1) another Polynomial    # 2) a Sequence object (such as a list or tuple)    # 3) a single float or int        # Store the data for the class as an instance attribute named __coefs    # which should store a tuple of floats. The zero polynomial should    # be represented by the empty tuple. The coefficients should be stored    # so that index i of the coefficients corresponds to the coefficient    # of x^i in the polynomial. The last entry in the tuple should be    # maintained as a non-zero value. Note that this may require trimming    # the entries of the data passed in if data is a Sequence object.    def __init__(self, data):        if isinstance(data, Polynomial):            self.__coefs = _trim(data.__coefs)        elif isinstance(data, collections.abc.Sequence):            self.__coefs = tuple(_trim([(item) for item in data])) #originally float(item)        elif isinstance(data, (int, float)):            if data:                self.__coefs = (float(data), )            else:                self.__coefs = tuple()        else:            #raise an error here            raise "Invalid Input"                # Return a representation that could be used to reconstruct the object.    def __repr__(self):        return f"Polynomial({tuple(map(float, self.__coefs))})"        # Return a "pretty" string representation of the object.    def __str__(self):        if len(self.__coefs) == 0:            return "0.0"        else:            res = str(float(self.__coefs[0]))            for i in range(1, len(self.__coefs)):                if self.__coefs[i] >= 0:                    res += ' + ' + str(float(self.__coefs[i]))                else:                    res += ' - ' + str(float(-self.__coefs[i]))                res += f"x^{i}"            return res        # hash function, no need to modify.    def __hash__(self):         if len(self.__coefs) == 0:            return hash(0)        elif len(self.__coefs) == 1:            return hash(self.__coefs[0])        else:            return hash(repr(self))        # Check for equality. Note that other may be a Polynomial or     # an int or float.        def __eq__(self, other):                other_pol = Polynomial(other) #is this right?        if self.__coefs == other_pol.__coefs:            return True        else:            return False                # return whether the self.__coefs object equals to other.__coefs or not by ==        # Unary plus operator.    def __pos__(self):        return Polynomial(self)        # Unary minus operator    def __neg__(self):        neg_data = []        for elem in self.__coefs:            neg_data.append(elem * -1)         return Polynomial(tuple(neg_data))    #need to change the sign of each coefficient, neg to pos and pos to neg    #list comprehension of self.__coefs, then change the sign of each element        # Polynomial addition. Note that rhs may be either a Polynomial or an    # int or float.    def __add__(self, rhs):        rhs = Polynomial(rhs)        coef1, coef2 = _pad(self.__coefs, rhs.__coefs)        new_coefs = [ele1 + ele2 for ele1, ele2 in zip(coef1, coef2)]        new_coefs = _trim(new_coefs)        return Polynomial(new_coefs)        # Right addition operator. Note that lhs may be either a Polynomial or     # an int or float.    def __radd__(self, lhs):        return self.__add__(lhs)        # Subtraction operator. Note that rhs may be either a Polynomial or an    # int or float.    def __sub__(self, rhs):        return self + (-Polynomial(rhs))        # Right subtraction operator. Note that lhs may be either a Polynomial or     # an int or float.    def __rsub__(self, lhs):        return Polynomial(lhs) + (-self)        # Multiplication operator. Note that rhs may be either a Polynomial or    # an int or float.    def __mul__(self, rhs):        rhs = Polynomial(rhs)                new_data = [0.] * (len(self.__coefs) + len(rhs.__coefs))                for i in range(len(self.__coefs)):            for j in range(len(rhs.__coefs)):                new_data[i+j] += (rhs.__coefs[j] * self.__coefs[i]) #check if works!                        return Polynomial(new_data)        # Right multiplication operator. Note that lhs may be either a Polynomial    # or an int or float.    def __rmul__(self, lhs):        return self.__mul__(lhs)            # Subscript operator []. index should be a non-negative integer. This    # should support obtaining the coefficient of x^i in the polynomial,    # even if i exceeds the degree of the polynomial (the coefficient is zero    # in that case).    def __getitem__(self, index):                if index < 0:#check whether index is greater than 0 or not, if not raise an error:            raise ValueError("Index not greater than 0")        if index >= len(self.__coefs): #check whether index is greater than len(self.__coefs),            return 0        else:            return self.__coefs[index] #index by itself?        # Parentheses operator. This function should evaluate the polynomial    # by substituting value into the polynomial.    def __call__(self, value):                return float(sum(self.__coefs[i]*value**i for i in range(len(self.__coefs))))        # Returns the degree of the polynomial. Note that the degree of the zero    # polynomial is -inf by convention. (You could use -float("inf") or     # -math.inf for this value.)    def degree(self):                if len(self.__coefs) == 0: #check whether the len of self.__coefs equals to 0 or not, if 0, return -math.inf            return -math.inf        else:            return len(self.__coefs) - 1            # Returns False for the zero polynomial, and True otherwise.    def __bool__(self):                if len(self.__coefs) == 0:            return False                else:            return True        #if lenth of polynomial equal 0, return False, else return True (check length of self.__coefs)        # pow function (for ** and pow). The exponent should be a non-negative    # integer. Note that any polynomial to the zeroth power should return    # a degree zero monic polynomial.    def __pow__(self, e):        if not isinstance(e, int):#check e instance of int (is it an int)            raise TypeError("e is not an integer")            elif e < 0: # check e >= 0            raise ValueError("e must be non-negative")                   elif e == 0:            return Polynomial((1.,))                np = Polynomial(self.__coefs)        for i in range(e-1):            np = np.__mul__(self)                    return np                    # return the derivative of a polynomial.    def prime(self):                new_coefs = [i * self.__coefs[i] for i in range(1, len(self.__coefs))]                return Polynomial(new_coefs)    # return a monic (leading coefficient 1) monomial of the specified # (non-negative) degree. Note that this function is not a method of the # Polynomial class, although it should return a Polynomial object.def monomial(degree):        return Polynomial([0.] * degree + [1.])        #if degree = 4, f = x^4 (what this function does)f = Polynomial([1,2,3,])g = Polynomial(f)print(f+g)